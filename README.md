# Input Validation

My program compiles with the following command

```g++ *.cpp -std=c++20 -o main.out```

As a note, because this uses c++ 20 features, you will need at least g++ version 10
It can then be run with the following command

```./main.out <inputFile>```

The input file is optional. If included it will be parsed on startup and the user data will automatically populate the database.
A valid input file will be a .txt where each pair of lines is a user. The first line will be the user’s name and the second line is their phone number. I have included `good.txt` with all valid inputs and `bad.txt` with all invalid inputs. The exception is Quiñones in `good.txt`. The second occurence will fail, showing that all forms of ñ compare equal as will be discussed later. It also shows how my program handles duplicates.

The bulk of my program is built around a loop that gets commands from the user. The ADD command prompts the user for a name and phone number to add to the database. I combined both DEL commands into one that first requests whether to delete by name or number and then removes it. The LIST command displays all users in the database. The EXIT command terminates the program. If at any point an invalid input is entered, the program redirects back to command selection. More detailed descriptions of each function and the consideration that went into them are below.

## ADD
Instead of having the user input the name and phone number at the same time as the ADD command, I ask for them one at a time. Most notably, this means that the name and phone number do not need to be separated from each other which could have been difficult because of some of the names I decided to allow. I wanted my database to allow multiple people with the same name but a different phone number and vice versa. If a user is attempted to be added that has the same name and phone number as an existing user, it will not be added again. My primary goal for validating names was to not wrongfully reject any valid name.

My first thought was to also allow names from most any language with UTF-8 support. This caused some initial troubles as for the delete function to work, names need to be able to be accurately compared. An example of how this can cause trouble is the Spanish ñ character. In UTF-8 it can either be represented as its code or a combination of the ~ combining character and a Latin n character as ñ. Depending on how this is being viewed, the second may be displayed slightly differently or not. Importantly, even though they represent the same letter, they have different lengths and do not compare equal. I fixed this problem in two parts. First, while the phone numbers are stored as UTF-8 in std::string, the names are stored as UTF-32 in std::u32string. UTF-32, unlike UTF-8, is a fixed-length encoding scheme. Once in this new format, I was able to pass the name to a library that normalizes it. I have just copied the .h and .c of with the function that I needed into this project so the library function will compile along with my code. There are a variety of normalized forms which can be seen here http://unicode.org/reports/tr15/#Norm_Forms. I decided to go with type C which first breaks all characters that can be split into parts. It then combines all possible characters. While this only affects a handful of Spanish characters, in some other languages, as many as 4 characters can be combined into one. The second to last step in normalizing names is to replace all varieties of space characters with a normal space. Then any streches of consecutive whitespace are replace with a single space. Finaly, leading and trailing whitespace is removed.

The final step in the ADD command is to validate the name and phone number and check to see if that user already exists. If all these pass the user is added to the database.

## DEL
The DEL command starts by asking whether to search by name or phone number. Once one is selected they are handled essentially the same way. When either a name or phone number is input it is first normalized and validated. This is important so that the entered input will match the version that is stored. This is particularly important for the phone numbers as well because the validation modifies the phone number into an easier-to-match format. If the validation does not pass the operation is canceled. Next, the database is searched for all entries that have the same name or phone number that was entered. If no entries are found nothing happens. If one is found it is removed. If more than one is found, all potential matches are found and displayed with both name and phone number, and then the program prompts which one would like to be removed. If a valid choice is selected it is removed.

## Name Validation
Name validation is both very easy and very difficult. Because I didn't want to exclude any name that someone could have I did extensive research on naming laws. While I learned a lot about naming laws and how they vary from state to state and country to country it came down to one fact. Some places have no restrictions on names. One notable place like such is Kentucky whose baby-naming laws can be found at https://apps.legislature.ky.gov/law/statutes/statute.aspx?id=50029 and explicitly states any name can be chosen. This led me to only restrict characters from names that could never appear in a name. Largely, the restricted characters are Unicode control characters. There are also a handful of invisible characters removed and some unassigned values. Characters that are not visible themselves but do affect the appearance of other characters were left in. An example of this is the characters that designate if text is displayed from left-to-right or right-to-left. There are some gaps in UTF-8 that are unassigned but most are reserved for future expansion of current alphabets which I decided to leave in. Only two stretches of unassigned characters are reserved for future control characters and both stretches are restricted. A final check also makes sure the name is not an empty string and does not consist of only whitespace.

All in all not much will cause a name to fail validation. I realize this list allows through many problematic or malicious names but they are not dangerous in the context of this program. Importantly it is technically possible for someone to have one of these names including `Robert'); DROP TABLE Students;--` and it would be possible for them to safely use this program. This solution may seem like a bit of a cop out, but I can gurantee that lots of research and thought was put into making it work exactly as intended.

## Phone Number Validation
Phone number validation was a much more involved process. I was tempted to use google's libphonenumber which can be downloaded for free at https://github.com/google/libphonenumber, but between not wanting to go through the process of setting it up and wanting to attempt validating the phone numbers myself I decided not to.

The first step in validating a phone number is to reject everything that is obviously not a phone number. This only lets through strings with numbers and a handful of characters that are also used in phone numbers. Notably, all letters are also allowed because they could be used to delineate an extension. If any letters are present special steps are taken to detect and extract an extension after making them all lowercase. Extensions can be delineated by `Extention`, `ext.`, or `x`. All three of these cases have exactly one occurrence of an x. I change any occurrences of the first two to match the last. At this point, if there are any letters other than 1 'x' the phone number is invalid. The extension is then removed from the phone number and restricted to between 1 and 15 digits. I could find no formal limit to the length of extensions. Some places limited them to 4 digits, but I also found some discussion of much longer extensions being used as a mask on the phone number itself. In order to allow this use case, I capped the length at 15.

Next, some general processing is applied to the phone number to remove non-number characters and validate they were being used in a correct way. The `+` sign was allowed through to identify international numbers. If a number is determined to be international, a few checks are done. The first part of the number is compared to all valid country codes to make sure it is a valid international number. I decided to then only verify that the length of the number was between 7 and 15 digits, the max and min length I could find for any number worldwide. No further processing is done to verify that any given phone number matches the format for its country except in North America. Numbers that either had no country code or a North American code are further processed. This is some simple checking to make sure the number is 10 digits and the area code is both valid and in use. I decided to deny the 5 and 6-digit SMS numbers even though they are valid numbers because there would be no way for one of these numbers to belong to someone as a personal number. The final step in the process is to append the cleaned extension to the end of the number if one was found.